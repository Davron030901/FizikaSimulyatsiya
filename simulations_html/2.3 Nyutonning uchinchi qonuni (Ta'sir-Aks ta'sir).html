<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.3 Nyutonning uchinchi qonuni (Ta'sir-Aks ta'sir)</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }
        .header h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            color: #666;
        }

        .formula-box {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
            font-size: 1.8em;
            font-weight: bold;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .simulation-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .simulation-title {
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            border: 2px solid #667eea;
            border-radius: 10px;
            background: white;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-weight: bold;
            color: #667eea;
            font-size: 0.9em;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        input[type="range"] {
            width: 120px;
            margin: 5px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            text-align: center;
        }

        .info-panel {
            background: #e8f2ff;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .info-panel h3 {
            color: #667eea;
            margin-top: 0;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .tab {
            padding: 10px 20px;
            background: #f0f0f0;
            border: 2px solid #667eea;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab:hover {
            background: #764ba2;
            color: white;
        }

        .simulation-content {
            display: none;
        }

        .simulation-content.active {
            display: block;
        }

        .vector-display {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 10px;
        }

        .vector-info {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .vector-info h4 {
            color: #667eea;
            margin: 0 0 10px 0;
        }

        .force-arrow {
            font-size: 2em;
            color: #ff4444;
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .example-card {
            background: white;
            border: 2px solid #667eea;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .example-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .example-card h3 {
            color: #667eea;
            margin-top: 0;
        }

        .example-card img {
            width: 100%;
            max-width: 200px;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            margin: 10px 0;
        }

        .explanation {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .explanation h3 {
            color: #856404;
            margin-top: 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            canvas {
                width: 100%;
                max-width: 100%;
                height: auto;
            }
            
            .tabs {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .tab {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .formula-box {
                font-size: 1.5em;
                padding: 15px;
            }
            
            .examples {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2.3 Nyutonning uchinchi qonuni</h1>
            <p>Ta'sir-Aks ta'sir qonuni</p>
        </div>

        <div class="formula-box">
            F₁₂ = -F₂₁
            <br>
            <small>Har bir ta'sirga teng va qarama-qarshi aks ta'sir mavjud</small>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="showSimulation('collision')">Jismlar to'qnashuvi</div>
            <div class="tab" onclick="showSimulation('rocket')">Raketa harakati</div>
            <div class="tab" onclick="showSimulation('walking')">Yurish mexanizmi</div>
            <div class="tab" onclick="showSimulation('forces')">Kuch vektorlari</div>
        </div>

        <!-- Collision Simulation -->
        <div id="collision" class="simulation-content active">
            <div class="simulation-container">
                <div class="simulation-title">Jismlar to'qnashuvi simulyatsiyasi</div>
                <canvas id="collisionCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Massa 1 (kg)</label>
                        <input type="number" id="mass1" value="5" min="1" max="20">
                    </div>
                    <div class="control-group">
                        <label>Massa 2 (kg)</label>
                        <input type="number" id="mass2" value="3" min="1" max="20">
                    </div>
                    <div class="control-group">
                        <label>Tezlik 1 (m/s)</label>
                        <input type="number" id="velocity1" value="8" min="0" max="20">
                    </div>
                    <div class="control-group">
                        <label>Tezlik 2 (m/s)</label>
                        <input type="number" id="velocity2" value="0" min="0" max="20">
                    </div>
                    <button onclick="startCollision()">Simulyatsiyani boshlash</button>
                    <button onclick="resetCollision()">Qayta boshlash</button>
                </div>
                <div class="vector-display">
                    <div class="vector-info">
                        <h4>Jism 1 ga ta'sir</h4>
                        <div class="force-arrow">←</div>
                        <div id="force1Display">F₁ = 0 N</div>
                    </div>
                    <div class="vector-info">
                        <h4>Jism 2 ga ta'sir</h4>
                        <div class="force-arrow">→</div>
                        <div id="force2Display">F₂ = 0 N</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rocket Simulation -->
        <div id="rocket" class="simulation-content">
            <div class="simulation-container">
                <div class="simulation-title">Raketa harakati simulyatsiyasi</div>
                <canvas id="rocketCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Yonilg'i tezligi (m/s)</label>
                        <input type="range" id="fuelVelocity" min="10" max="100" value="50">
                        <span id="fuelVelocityValue">50</span>
                    </div>
                    <div class="control-group">
                        <label>Yonilg'i sarfi (kg/s)</label>
                        <input type="range" id="fuelRate" min="1" max="10" value="5">
                        <span id="fuelRateValue">5</span>
                    </div>
                    <button onclick="startRocket()">Raketani ishga tushirish</button>
                    <button onclick="resetRocket()">Qayta boshlash</button>
                </div>
                <div class="vector-display">
                    <div class="vector-info">
                        <h4>Gazlarga ta'sir</h4>
                        <div class="force-arrow">↓</div>
                        <div id="gasForceDisplay">F_gaz = 0 N</div>
                    </div>
                    <div class="vector-info">
                        <h4>Raketaga ta'sir</h4>
                        <div class="force-arrow">↑</div>
                        <div id="rocketForceDisplay">F_raketa = 0 N</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Walking Simulation -->
        <div id="walking" class="simulation-content">
            <div class="simulation-container">
                <div class="simulation-title">Yurish mexanizmi simulyatsiyasi</div>
                <canvas id="walkingCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Yurish tezligi</label>
                        <input type="range" id="walkSpeed" min="1" max="10" value="5">
                        <span id="walkSpeedValue">5</span>
                    </div>
                    <div class="control-group">
                        <label>Ishqalanish koeffitsienti</label>
                        <input type="range" id="friction" min="0.1" max="1" step="0.1" value="0.5">
                        <span id="frictionValue">0.5</span>
                    </div>
                    <button onclick="startWalking()">Yurishni boshlash</button>
                    <button onclick="stopWalking()">To'xtatish</button>
                </div>
                <div class="vector-display">
                    <div class="vector-info">
                        <h4>Yerga ta'sir</h4>
                        <div class="force-arrow">→</div>
                        <div id="groundForceDisplay">F_yer = 0 N</div>
                    </div>
                    <div class="vector-info">
                        <h4>Odamga ta'sir</h4>
                        <div class="force-arrow">←</div>
                        <div id="humanForceDisplay">F_odam = 0 N</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Forces Simulation -->
        <div id="forces" class="simulation-content">
            <div class="simulation-container">
                <div class="simulation-title">Kuch vektorlari simulyatsiyasi</div>
                <canvas id="forcesCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Kuch kattaligi (N)</label>
                        <input type="range" id="forceMagnitude" min="10" max="200" value="100">
                        <span id="forceMagnitudeValue">100</span>
                    </div>
                    <div class="control-group">
                        <label>Kuch yo'nalishi (°)</label>
                        <input type="range" id="forceDirection" min="0" max="360" value="0">
                        <span id="forceDirectionValue">0</span>
                    </div>
                    <button onclick="applyForce()">Kuch qo'llash</button>
                    <button onclick="resetForces()">Qayta boshlash</button>
                </div>
                <div class="vector-display">
                    <div class="vector-info">
                        <h4>Ta'sir kuchi</h4>
                        <div id="actionForceDisplay">F_action = 0 N</div>
                    </div>
                    <div class="vector-info">
                        <h4>Aks ta'sir kuchi</h4>
                        <div id="reactionForceDisplay">F_reaction = 0 N</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>Simulyatsiya ko'rsatmalari</h3>
            <p><strong>Ranglar:</strong></p>
            <ul>
                <li><span style="color: #ff4444;">🔴 Qizil</span> - Ta'sir kuchi</li>
                <li><span style="color: #4444ff;">🔵 Ko'k</span> - Aks ta'sir kuchi</li>
                <li><span style="color: #00ff00;">🟢 Yashil</span> - Tezlik vektori</li>
            </ul>
            <p><strong>Eslatma:</strong> Barcha simulyatsiyalarda kuchlar F₁₂ = -F₂₁ qonuniga bo'ysunadi.</p>
        </div>

        <div class="examples">
            <div class="example-card">
                <h3>Mashina harakati</h3>
                <div style="width: 100%; height: 150px; background: #f0f0f0; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 3em;">🚗</div>
                <p>Mashina g'ildiraklari yerga kuch qo'llaydi, yer esa mashinaga qarama-qarshi kuch qo'llaydi.</p>
            </div>
            <div class="example-card">
                <h3>Suzish</h3>
                <div style="width: 100%; height: 150px; background: #e6f3ff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 3em;">🏊</div>
                <p>Suzuvchi suvni orqaga itaradi, suv esa suzuvchini oldinga itaradi.</p>
            </div>
            <div class="example-card">
                <h3>Qush parvozi</h3>
                <div style="width: 100%; height: 150px; background: #f0f8ff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 3em;">🐦</div>
                <p>Qush qanotlari bilan havoni pastga itaradi, havo esa qushni yuqoriga ko'taradi.</p>
            </div>
        </div>

        <div class="explanation">
            <h3>Nyutonning uchinchi qonuni tushunchasi</h3>
            <p><strong>Asosiy printsip:</strong> Har bir ta'sirga teng va qarama-qarshi aks ta'sir mavjud.</p>
            <p><strong>Muhim xususiyatlar:</strong></p>
            <ul>
                <li>Ta'sir va aks ta'sir kuchlari har doim teng kattalikda</li>
                <li>Bu kuchlar har doim qarama-qarshi yo'nalishda</li>
                <li>Kuchlar turli jismlarga ta'sir qiladi</li>
                <li>Kuchlar bir vaqtda paydo bo'ladi va yo'qoladi</li>
            </ul>
            <p><strong>Amaliy misollar:</strong></p>
            <ul>
                <li>Yurish: oyoq yerga itaradi, yer oyoqni oldinga itaradi</li>
                <li>Otish: o'q oldinga, qurol orqaga harakatlanadi</li>
                <li>Suzish: qo'l suvni orqaga, suv qo'lni oldinga itaradi</li>
                <li>Raketa: gaz pastga, raketa yuqoriga harakatlanadi</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let animationId;
        let currentTab = 'collision';
        
        // Utility function to draw arrows
        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Draw arrow head
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const arrowLength = 10;
            const arrowAngle = Math.PI / 6;
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - arrowLength * Math.cos(angle - arrowAngle), toY - arrowLength * Math.sin(angle - arrowAngle));
            ctx.lineTo(toX - arrowLength * Math.cos(angle + arrowAngle), toY - arrowLength * Math.sin(angle + arrowAngle));
            ctx.closePath();
            ctx.fill();
        }
        
        // Canvas contexts
        const collisionCanvas = document.getElementById('collisionCanvas');
        const collisionCtx = collisionCanvas.getContext('2d');
        const rocketCanvas = document.getElementById('rocketCanvas');
        const rocketCtx = rocketCanvas.getContext('2d');
        const walkingCanvas = document.getElementById('walkingCanvas');
        const walkingCtx = walkingCanvas.getContext('2d');
        const forcesCanvas = document.getElementById('forcesCanvas');
        const forcesCtx = forcesCanvas.getContext('2d');

        // Simulation states
        let collisionState = {
            balls: [],
            collided: false,
            forces: { f1: 0, f2: 0 }
        };

        let rocketState = {
            rocket: { x: 100, y: 350, vx: 0, vy: 0, fuel: 100 },
            particles: [],
            thrust: 0
        };

        let walkingState = {
            person: { x: 100, y: 200, step: 0 },
            forces: { ground: 0, person: 0 },
            walking: false
        };

        let forcesState = {
            objects: [
                { x: 300, y: 200, vx: 0, vy: 0 },
                { x: 500, y: 200, vx: 0, vy: 0 }
            ],
            forces: { action: 0, reaction: 0 }
        };

        // Tab management
        function showSimulation(tabName) {
            // Hide all simulation contents
            document.querySelectorAll('.simulation-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected simulation
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            currentTab = tabName;
            
            // Stop any running animations
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Reset simulations
            resetAllSimulations();
        }

        function resetAllSimulations() {
            resetCollision();
            resetRocket();
            stopWalking();
            resetForces();
        }

        // Collision Simulation
        function initCollision() {
            const mass1 = parseFloat(document.getElementById('mass1').value);
            const mass2 = parseFloat(document.getElementById('mass2').value);
            const vel1 = parseFloat(document.getElementById('velocity1').value);
            const vel2 = parseFloat(document.getElementById('velocity2').value);

            collisionState.balls = [
                {
                    x: 150,
                    y: 200,
                    vx: vel1,
                    vy: 0,
                    mass: mass1,
                    radius: Math.sqrt(mass1) * 5 + 10,
                    color: '#ff4444'
                },
                {
                    x: 650,
                    y: 200,
                    vx: -vel2,
                    vy: 0,
                    mass: mass2,
                    radius: Math.sqrt(mass2) * 5 + 10,
                    color: '#4444ff'
                }
            ];
            collisionState.collided = false;
            collisionState.forces = { f1: 0, f2: 0 };
        }

        function startCollision() {
            initCollision();
            animateCollision();
        }

        function resetCollision() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            initCollision();
            drawCollision();
            updateCollisionForces();
        }

        function animateCollision() {
            updateCollision();
            drawCollision();
            updateCollisionForces();
            
            if (currentTab === 'collision') {
                animationId = requestAnimationFrame(animateCollision);
            }
        }

        function updateCollision() {
            const ball1 = collisionState.balls[0];
            const ball2 = collisionState.balls[1];

            // Check collision
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ball1.radius + ball2.radius;

            if (distance < minDistance && !collisionState.collided) {
                collisionState.collided = true;
                
                // Calculate collision forces
                const totalMass = ball1.mass + ball2.mass;
                const relativeVelocity = Math.abs(ball1.vx - ball2.vx);
                const force = (ball1.mass * ball2.mass * relativeVelocity) / (totalMass * 0.1);
                
                collisionState.forces.f1 = force;
                collisionState.forces.f2 = force;

                // Elastic collision
                const v1 = ((ball1.mass - ball2.mass) * ball1.vx + 2 * ball2.mass * ball2.vx) / totalMass;
                const v2 = ((ball2.mass - ball1.mass) * ball2.vx + 2 * ball1.mass * ball1.vx) / totalMass;
                
                ball1.vx = v1;
                ball2.vx = v2;
                
                // Separate balls
                const overlap = minDistance - distance;
                const separationX = (overlap / 2) * (dx / distance);
                ball1.x -= separationX;
                ball2.x += separationX;
                
                // Gradually reduce forces
                setTimeout(() => {
                    collisionState.forces.f1 *= 0.3;
                    collisionState.forces.f2 *= 0.3;
                }, 200);
                
                setTimeout(() => {
                    collisionState.collided = false;
                }, 500);
            }

            // Update positions
            ball1.x += ball1.vx;
            ball2.x += ball2.vx;

            // Bounce off walls
            if (ball1.x - ball1.radius < 0 || ball1.x + ball1.radius > collisionCanvas.width) {
                ball1.vx *= -0.8;
                ball1.x = Math.max(ball1.radius, Math.min(collisionCanvas.width - ball1.radius, ball1.x));
            }
            if (ball2.x - ball2.radius < 0 || ball2.x + ball2.radius > collisionCanvas.width) {
                ball2.vx *= -0.8;
                ball2.x = Math.max(ball2.radius, Math.min(collisionCanvas.width - ball2.radius, ball2.x));
            }

            // Apply friction
            ball1.vx *= 0.999;
            ball2.vx *= 0.999;
            
            // Gradually reduce force display
            collisionState.forces.f1 *= 0.98;
            collisionState.forces.f2 *= 0.98;
        }

        function drawCollision() {
            collisionCtx.clearRect(0, 0, collisionCanvas.width, collisionCanvas.height);
            
            // Draw ground
            collisionCtx.fillStyle = '#8B4513';
            collisionCtx.fillRect(0, collisionCanvas.height - 20, collisionCanvas.width, 20);
            
            // Draw balls
            collisionState.balls.forEach((ball, index) => {
                collisionCtx.fillStyle = ball.color;
                collisionCtx.beginPath();
                collisionCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                collisionCtx.fill();
                
                // Draw mass label
                collisionCtx.fillStyle = 'white';
                collisionCtx.font = 'bold 16px Arial';
                collisionCtx.textAlign = 'center';
                collisionCtx.fillText(`${ball.mass}kg`, ball.x, ball.y + 5);
                
                // Draw velocity vector
                if (Math.abs(ball.vx) > 0.1) {
                    drawArrow(collisionCtx, ball.x, ball.y, ball.x + ball.vx * 10, ball.y, 'green');
                }
                
                // Draw force vector during collision
                if (collisionState.collided && (collisionState.forces.f1 > 0.1 || collisionState.forces.f2 > 0.1)) {
                    collisionCtx.strokeStyle = 'red';
                    collisionCtx.lineWidth = 4;
                    collisionCtx.beginPath();
                    collisionCtx.moveTo(ball.x, ball.y - ball.radius - 10);
                    const forceDirection = index === 0 ? -1 : 1;
                    const forceLength = Math.min((index === 0 ? collisionState.forces.f1 : collisionState.forces.f2) / 2, 80);
                    collisionCtx.lineTo(ball.x + forceDirection * forceLength, ball.y - ball.radius - 10);
                    collisionCtx.stroke();
                    
                    // Draw arrow head
                    collisionCtx.fillStyle = 'red';
                    collisionCtx.beginPath();
                    const arrowX = ball.x + forceDirection * forceLength;
                    const arrowY = ball.y - ball.radius - 10;
                    collisionCtx.moveTo(arrowX, arrowY);
                    collisionCtx.lineTo(arrowX - forceDirection * 8, arrowY - 5);
                    collisionCtx.lineTo(arrowX - forceDirection * 8, arrowY + 5);
                    collisionCtx.closePath();
                    collisionCtx.fill();
                }
            });
        }

        function updateCollisionForces() {
            document.getElementById('force1Display').textContent = `F₁ = ${collisionState.forces.f1.toFixed(1)} N`;
            document.getElementById('force2Display').textContent = `F₂ = ${collisionState.forces.f2.toFixed(1)} N`;
        }

        // Rocket Simulation
        function initRocket() {
            rocketState.rocket = { x: 100, y: 350, vx: 0, vy: 0, fuel: 100 };
            rocketState.particles = [];
            rocketState.thrust = 0;
        }

        function startRocket() {
            initRocket();
            animateRocket();
        }

        function resetRocket() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            initRocket();
            drawRocket();
            updateRocketForces();
        }

        function animateRocket() {
            if (rocketState.rocket.fuel > 0 || rocketState.rocket.vy !== 0 || rocketState.particles.length > 0) {
                updateRocket();
                drawRocket();
                updateRocketForces();
                
                if (currentTab === 'rocket') {
                    animationId = requestAnimationFrame(animateRocket);
                }
            } else {
                // Rocket has stopped completely
                updateRocketForces();
            }
        }

        function updateRocket() {
            const fuelVelocity = parseFloat(document.getElementById('fuelVelocity').value);
            const fuelRate = parseFloat(document.getElementById('fuelRate').value);
            
            if (rocketState.rocket.fuel > 0) {
                // Calculate thrust
                rocketState.thrust = fuelRate * fuelVelocity;
                
                // Apply thrust
                rocketState.rocket.vy -= rocketState.thrust / 1000;
                rocketState.rocket.fuel -= fuelRate / 10;
                
                // Add exhaust particles
                for (let i = 0; i < 3; i++) {
                    rocketState.particles.push({
                        x: rocketState.rocket.x + Math.random() * 20 - 10,
                        y: rocketState.rocket.y + 30,
                        vx: (Math.random() - 0.5) * 4,
                        vy: fuelVelocity / 10 + Math.random() * 5,
                        life: 30,
                        maxLife: 30
                    });
                }
            } else {
                rocketState.thrust = 0;
            }
            
            // Apply gravity
            rocketState.rocket.vy += 0.3;
            
            // Update rocket position
            rocketState.rocket.x += rocketState.rocket.vx;
            rocketState.rocket.y += rocketState.rocket.vy;
            
            // Keep rocket in bounds
            if (rocketState.rocket.y > 350) {
                rocketState.rocket.y = 350;
                rocketState.rocket.vy = 0;
            }
            
            // Update particles
            rocketState.particles = rocketState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                return particle.life > 0;
            });
        }

        function drawRocket() {
            rocketCtx.clearRect(0, 0, rocketCanvas.width, rocketCanvas.height);
            
            // Draw background
            const gradient = rocketCtx.createLinearGradient(0, 0, 0, rocketCanvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            rocketCtx.fillStyle = gradient;
            rocketCtx.fillRect(0, 0, rocketCanvas.width, rocketCanvas.height);
            
            // Draw ground
            rocketCtx.fillStyle = '#8B4513';
            rocketCtx.fillRect(0, rocketCanvas.height - 20, rocketCanvas.width, 20);
            
            // Draw exhaust particles
            rocketState.particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                rocketCtx.fillStyle = `rgba(255, ${100 + Math.floor(155 * alpha)}, 0, ${alpha})`;
                rocketCtx.beginPath();
                rocketCtx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                rocketCtx.fill();
            });
            
            // Draw rocket
            rocketCtx.fillStyle = '#C0C0C0';
            rocketCtx.fillRect(rocketState.rocket.x - 10, rocketState.rocket.y - 30, 20, 60);
            
            // Draw rocket nose
            rocketCtx.fillStyle = '#FF0000';
            rocketCtx.beginPath();
            rocketCtx.moveTo(rocketState.rocket.x, rocketState.rocket.y - 30);
            rocketCtx.lineTo(rocketState.rocket.x - 10, rocketState.rocket.y - 10);
            rocketCtx.lineTo(rocketState.rocket.x + 10, rocketState.rocket.y - 10);
            rocketCtx.closePath();
            rocketCtx.fill();
            
            // Draw fuel gauge
            rocketCtx.fillStyle = '#000';
            rocketCtx.fillRect(20, 20, 200, 20);
            rocketCtx.fillStyle = rocketState.rocket.fuel > 20 ? '#00FF00' : '#FF0000';
            rocketCtx.fillRect(22, 22, (rocketState.rocket.fuel / 100) * 196, 16);
            
            rocketCtx.fillStyle = '#000';
            rocketCtx.font = '14px Arial';
            rocketCtx.fillText(`Yonilg'i: ${rocketState.rocket.fuel.toFixed(1)}%`, 25, 55);
            
            // Draw thrust vector
            if (rocketState.thrust > 0) {
                drawArrow(rocketCtx, rocketState.rocket.x, rocketState.rocket.y - 40,
                         rocketState.rocket.x, rocketState.rocket.y - 40 - rocketState.thrust / 5, 'blue');
            }
        }

        function updateRocketForces() {
            document.getElementById('gasForceDisplay').textContent = `F_gaz = ${rocketState.thrust.toFixed(1)} N`;
            document.getElementById('rocketForceDisplay').textContent = `F_raketa = ${rocketState.thrust.toFixed(1)} N`;
        }

        // Walking Simulation
        function initWalking() {
            walkingState.person = { x: 100, y: 200, step: 0 };
            walkingState.forces = { ground: 0, person: 0 };
            walkingState.walking = false;
        }

        function startWalking() {
            walkingState.walking = true;
            animateWalking();
        }

        function stopWalking() {
            walkingState.walking = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            walkingState.forces = { ground: 0, person: 0 };
            updateWalkingForces();
        }

        function animateWalking() {
            if (walkingState.walking) {
                updateWalking();
                drawWalking();
                updateWalkingForces();
                
                if (currentTab === 'walking') {
                    animationId = requestAnimationFrame(animateWalking);
                }
            }
        }

        function updateWalking() {
            const walkSpeed = parseFloat(document.getElementById('walkSpeed').value);
            const friction = parseFloat(document.getElementById('friction').value);
            
            if (walkingState.walking) {
                walkingState.step += walkSpeed / 10;
                walkingState.person.x += walkSpeed / 2;
                
                // Calculate forces
                const force = walkSpeed * friction * 10;
                walkingState.forces.ground = force;
                walkingState.forces.person = force;
                
                // Reset position if person walks off screen
                if (walkingState.person.x > walkingCanvas.width + 50) {
                    walkingState.person.x = -50;
                }
            }
        }

        function drawWalking() {
            walkingCtx.clearRect(0, 0, walkingCanvas.width, walkingCanvas.height);
            
            // Draw ground
            walkingCtx.fillStyle = '#8B4513';
            walkingCtx.fillRect(0, walkingCanvas.height - 50, walkingCanvas.width, 50);
            
            // Draw person (simplified stick figure)
            walkingCtx.strokeStyle = '#000';
            walkingCtx.lineWidth = 4;
            
            // Head
            walkingCtx.beginPath();
            walkingCtx.arc(walkingState.person.x, walkingState.person.y - 80, 20, 0, Math.PI * 2);
            walkingCtx.stroke();
            
            // Body
            walkingCtx.beginPath();
            walkingCtx.moveTo(walkingState.person.x, walkingState.person.y - 60);
            walkingCtx.lineTo(walkingState.person.x, walkingState.person.y - 10);
            walkingCtx.stroke();
            
            // Arms
            walkingCtx.beginPath();
            walkingCtx.moveTo(walkingState.person.x - 20, walkingState.person.y - 40);
            walkingCtx.lineTo(walkingState.person.x + 20, walkingState.person.y - 40);
            walkingCtx.stroke();
            
            // Legs (animated)
            const legOffset = Math.sin(walkingState.step) * 20;
            walkingCtx.beginPath();
            walkingCtx.moveTo(walkingState.person.x, walkingState.person.y - 10);
            walkingCtx.lineTo(walkingState.person.x - legOffset, walkingState.person.y + 30);
            walkingCtx.moveTo(walkingState.person.x, walkingState.person.y - 10);
            walkingCtx.lineTo(walkingState.person.x + legOffset, walkingState.person.y + 30);
            walkingCtx.stroke();
            
            // Draw force vectors
            if (walkingState.walking && walkingState.forces.person > 0) {
                // Force from person to ground (push back)
                drawArrow(walkingCtx, walkingState.person.x, walkingState.person.y + 35, 
                         walkingState.person.x + walkingState.forces.person * 0.8, walkingState.person.y + 35, 'red');
                
                // Force from ground to person (push forward)
                drawArrow(walkingCtx, walkingState.person.x, walkingState.person.y + 45, 
                         walkingState.person.x - walkingState.forces.ground * 0.8, walkingState.person.y + 45, 'blue');
                
                // Labels
                walkingCtx.fillStyle = 'red';
                walkingCtx.font = '12px Arial';
                walkingCtx.fillText('F_odam→yer', walkingState.person.x + 10, walkingState.person.y + 30);
                walkingCtx.fillStyle = 'blue';
                walkingCtx.fillText('F_yer→odam', walkingState.person.x - 80, walkingState.person.y + 55);
            }
        }

        function updateWalkingForces() {
            document.getElementById('groundForceDisplay').textContent = `F_yer = ${walkingState.forces.ground.toFixed(1)} N`;
            document.getElementById('humanForceDisplay').textContent = `F_odam = ${walkingState.forces.person.toFixed(1)} N`;
        }

        // Forces Simulation
        function initForces() {
            forcesState.objects = [
                { x: 300, y: 200, vx: 0, vy: 0 },
                { x: 500, y: 200, vx: 0, vy: 0 }
            ];
            forcesState.forces = { action: 0, reaction: 0 };
        }

        function applyForce() {
            const magnitude = parseFloat(document.getElementById('forceMagnitude').value);
            const direction = parseFloat(document.getElementById('forceDirection').value) * Math.PI / 180;
            
            forcesState.forces.action = magnitude;
            forcesState.forces.reaction = magnitude;
            
            // Apply force to objects
            forcesState.objects[0].vx += Math.cos(direction) * magnitude / 100;
            forcesState.objects[0].vy += Math.sin(direction) * magnitude / 100;
            
            forcesState.objects[1].vx -= Math.cos(direction) * magnitude / 100;
            forcesState.objects[1].vy -= Math.sin(direction) * magnitude / 100;
            
            animateForces();
        }

        function resetForces() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            initForces();
            drawForces();
            updateForcesDisplay();
        }

        function animateForces() {
            updateForcesObjects();
            drawForces();
            updateForcesDisplay();
            
            if (currentTab === 'forces') {
                animationId = requestAnimationFrame(animateForces);
            }
        }

        function updateForcesObjects() {
            forcesState.objects.forEach(obj => {
                obj.x += obj.vx;
                obj.y += obj.vy;
                
                // Apply friction
                obj.vx *= 0.98;
                obj.vy *= 0.98;
                
                // Bounce off walls
                if (obj.x < 25 || obj.x > forcesCanvas.width - 25) {
                    obj.vx *= -0.8;
                    obj.x = Math.max(25, Math.min(forcesCanvas.width - 25, obj.x));
                }
                if (obj.y < 25 || obj.y > forcesCanvas.height - 25) {
                    obj.vy *= -0.8;
                    obj.y = Math.max(25, Math.min(forcesCanvas.height - 25, obj.y));
                }
            });
            
            // Gradually reduce force display
            forcesState.forces.action *= 0.95;
            forcesState.forces.reaction *= 0.95;
        }

        function drawForces() {
            forcesCtx.clearRect(0, 0, forcesCanvas.width, forcesCanvas.height);
            
            // Draw grid
            forcesCtx.strokeStyle = '#f0f0f0';
            forcesCtx.lineWidth = 1;
            for (let i = 0; i < forcesCanvas.width; i += 50) {
                forcesCtx.beginPath();
                forcesCtx.moveTo(i, 0);
                forcesCtx.lineTo(i, forcesCanvas.height);
                forcesCtx.stroke();
            }
            for (let i = 0; i < forcesCanvas.height; i += 50) {
                forcesCtx.beginPath();
                forcesCtx.moveTo(0, i);
                forcesCtx.lineTo(forcesCanvas.width, i);
                forcesCtx.stroke();
            }
            
            // Draw objects
            forcesState.objects.forEach((obj, index) => {
                forcesCtx.fillStyle = index === 0 ? '#ff4444' : '#4444ff';
                forcesCtx.beginPath();
                forcesCtx.arc(obj.x, obj.y, 25, 0, Math.PI * 2);
                forcesCtx.fill();
                
                // Draw velocity vectors
                if (Math.abs(obj.vx) > 0.1 || Math.abs(obj.vy) > 0.1) {
                    drawArrow(forcesCtx, obj.x, obj.y, obj.x + obj.vx * 10, obj.y + obj.vy * 10, 'green');
                }
            });
            
            // Draw force vectors
            if (forcesState.forces.action > 1) {
                const magnitude = forcesState.forces.action;
                const direction = parseFloat(document.getElementById('forceDirection').value) * Math.PI / 180;
                
                // Action force
                drawArrow(forcesCtx, forcesState.objects[0].x, forcesState.objects[0].y,
                         forcesState.objects[0].x + Math.cos(direction) * magnitude / 2,
                         forcesState.objects[0].y + Math.sin(direction) * magnitude / 2, 'red');
                
                // Reaction force
                drawArrow(forcesCtx, forcesState.objects[1].x, forcesState.objects[1].y,
                         forcesState.objects[1].x - Math.cos(direction) * magnitude / 2,
                         forcesState.objects[1].y - Math.sin(direction) * magnitude / 2, 'blue');
            }
        }

        function updateForcesDisplay() {
            document.getElementById('actionForceDisplay').textContent = `F_action = ${forcesState.forces.action.toFixed(1)} N`;
            document.getElementById('reactionForceDisplay').textContent = `F_reaction = ${forcesState.forces.reaction.toFixed(1)} N`;
        }

        // Update slider values
        document.getElementById('fuelVelocity').oninput = function() {
            document.getElementById('fuelVelocityValue').textContent = this.value;
        };

        document.getElementById('fuelRate').oninput = function() {
            document.getElementById('fuelRateValue').textContent = this.value;
        };

        document.getElementById('walkSpeed').oninput = function() {
            document.getElementById('walkSpeedValue').textContent = this.value;
        };

        document.getElementById('friction').oninput = function() {
            document.getElementById('frictionValue').textContent = this.value;
        };

        document.getElementById('forceMagnitude').oninput = function() {
            document.getElementById('forceMagnitudeValue').textContent = this.value;
        };

        document.getElementById('forceDirection').oninput = function() {
            document.getElementById('forceDirectionValue').textContent = this.value;
        };

        // Initialize all simulations
        window.onload = function() {
            // Make canvases responsive
            resizeCanvases();
            
            initCollision();
            drawCollision();
            updateCollisionForces();
            
            initRocket();
            drawRocket();
            updateRocketForces();
            
            initWalking();
            drawWalking();
            updateWalkingForces();
            
            initForces();
            drawForces();
            updateForcesDisplay();
        };
        
        // Resize canvases for responsive design
        function resizeCanvases() {
            const canvases = [collisionCanvas, rocketCanvas, walkingCanvas, forcesCanvas];
            canvases.forEach(canvas => {
                const container = canvas.parentElement;
                const containerWidth = container.offsetWidth - 40; // Account for padding
                if (containerWidth < 800) {
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                }
            });
        }
        
        // Resize canvases on window resize
        window.addEventListener('resize', resizeCanvases);
    </script>
</body>
</html>


