<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1.7 Tezlik Vektori - Interaktiv Simulyatsiya</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .simulation-area {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            min-height: 600px;
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            height: fit-content;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
        }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            font-family: 'Courier New', monospace;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-section {
            margin-bottom: 25px;
        }

        .controls-section h3 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d3748;
        }
        
        .control-group input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .control-group label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .slider-container {
            position: relative;
            margin-bottom: 10px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .value-display {
            background: #f7fafc;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            text-align: center;
            margin-top: 5px;
            border: 1px solid #e2e8f0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-danger:hover {
            background: #c53030;
            transform: translateY(-2px);
        }

        .data-display {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #e2e8f0;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .data-label {
            font-weight: 600;
            color: #2d3748;
        }

        .data-value {
            font-family: 'Courier New', monospace;
            color: #4a5568;
        }

        .vector-info {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .vector-info h4 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            color: #4a5568;
        }

        .preset-btn:hover {
            background: #f7fafc;
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .theory-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .theory-section h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .formula-box {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .help-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            color: #667eea;
            font-weight: bold;
        }

        .help-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #2d3748;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 1000;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .speed-display {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            min-width: 50px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                order: -1;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                margin-bottom: 5px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.5em;
            }
            
            .preset-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>1.7 Tezlik Vektori</h1>
            <p>2D harakat va tezlik vektorining interaktiv simulyatsiyasi</p>
        </div>

        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="simulationCanvas"></canvas>
                    <div class="status-bar">
                        <span id="scaleInfo">Masshtab: 1:1</span>
                        <span id="mousePos">Kursor: (0, 0)</span>
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn btn-primary" id="playPauseBtn">▶️ Boshlash</button>
                    <button class="btn btn-secondary" id="resetBtn">🔄 Qayta boshlash</button>
                    <button class="btn btn-danger" id="clearTrailBtn">🧹 Izni tozalash</button>
                </div>
                <div class="button-group">
                    <button class="btn btn-secondary" id="zoomInBtn">🔍+ Kattalashtirish</button>
                    <button class="btn btn-secondary" id="zoomOutBtn">🔍- Kichiklashtirish</button>
                    <button class="btn btn-secondary" id="fitViewBtn">📐 To'liq ko'rish</button>
                </div>
            </div>

            <div class="control-panel">
                <div class="controls-section">
                    <h3>Harakat Parametrlari</h3>
                    
                    <div class="control-group">
                        <label>Boshlang'ich tezlik vₓ (m/s) <span class="help-tooltip" data-tooltip="Gorizontal yo'nalishdagi tezlik komponenti">?</span></label>
                        <div class="slider-container">
                            <input type="range" id="vxSlider" min="-50" max="50" value="20" step="1">
                            <div class="value-display" id="vxValue">20 m/s</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Boshlang'ich tezlik vᵧ (m/s) <span class="help-tooltip" data-tooltip="Vertikal yo'nalishdagi tezlik komponenti">?</span></label>
                        <div class="slider-container">
                            <input type="range" id="vySlider" min="-50" max="50" value="15" step="1">
                            <div class="value-display" id="vyValue">15 m/s</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Tezlanish aₓ (m/s²) <span class="help-tooltip" data-tooltip="Gorizontal yo'nalishdagi tezlanish">?</span></label>
                        <div class="slider-container">
                            <input type="range" id="axSlider" min="-10" max="10" value="0" step="0.1">
                            <div class="value-display" id="axValue">0.0 m/s²</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Tezlanish aᵧ (m/s²) <span class="help-tooltip" data-tooltip="Vertikal yo'nalishdagi tezlanish">?</span></label>
                        <div class="slider-container">
                            <input type="range" id="aySlider" min="-10" max="10" value="-9.8" step="0.1">
                            <div class="value-display" id="ayValue">-9.8 m/s²</div>
                        </div>
                    </div>
                </div>

                <div class="controls-section">
                    <h3>Ko'rish Sozlamalari</h3>
                    
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="autoScaleCheck" checked> 
                            Avtomatik masshtablash
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="showGridCheck" checked> 
                            Koordinata to'rini ko'rsatish
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="showTrailCheck" checked> 
                            Harakat izini ko'rsatish
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="showComponentsCheck" checked> 
                            Komponentlarni ko'rsatish
                        </label>
                    </div>
                </div>

                <div class="controls-section">
                    <h3>Simulyatsiya Tezligi</h3>
                    <div class="speed-control">
                        <label>Tezlik:</label>
                        <input type="range" id="speedSlider" min="0.1" max="3" value="1" step="0.1">
                        <div class="speed-display" id="speedValue">1.0x</div>
                    </div>
                </div>

                <div class="controls-section">
                    <h3>Tayyor Stsenariylar</h3>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="projectile">Proyektil</button>
                        <button class="preset-btn" data-preset="circular">Aylana</button>
                        <button class="preset-btn" data-preset="uniform">Tekis</button>
                        <button class="preset-btn" data-preset="deceleration">Sekinlanish</button>
                    </div>
                </div>

                <div class="vector-info">
                    <h4>Tezlik Vektori Ma'lumotlari</h4>
                    <div class="data-display">
                        <div class="data-row">
                            <span class="data-label">vₓ:</span>
                            <span class="data-value" id="currentVx">20.0 m/s</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">vᵧ:</span>
                            <span class="data-value" id="currentVy">15.0 m/s</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">|v⃗|:</span>
                            <span class="data-value" id="currentMagnitude">25.0 m/s</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">θ:</span>
                            <span class="data-value" id="currentAngle">36.9°</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Vaqt:</span>
                            <span class="data-value" id="currentTime">0.0 s</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Pozitsiya:</span>
                            <span class="data-value" id="currentPosition">(0, 0)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h2>Nazariy Asoslar</h2>
            
            <div class="formula-box">
                <h4>Tezlik Vektori Kattaligi</h4>
                <p>$$|\vec{v}| = \sqrt{v_x^2 + v_y^2}$$</p>
                <p>Bu formula Pifagor teoremasi asosida tezlik vektorining kattaligini hisoblaydi.</p>
            </div>

            <div class="formula-box">
                <h4>Tezlik Vektori Yo'nalishi</h4>
                <p>$$\theta = \arctan\left(\frac{v_y}{v_x}\right)$$</p>
                <p>Bu formula tezlik vektorining gorizontal o'q bilan hosil qilgan burchagini beradi.</p>
            </div>

            <div class="formula-box">
                <h4>Kinematik Tenglamalar</h4>
                <p>$$v_x(t) = v_{0x} + a_x \cdot t$$</p>
                <p>$$v_y(t) = v_{0y} + a_y \cdot t$$</p>
                <p>$$x(t) = x_0 + v_{0x} \cdot t + \frac{1}{2}a_x \cdot t^2$$</p>
                <p>$$y(t) = y_0 + v_{0y} \cdot t + \frac{1}{2}a_y \cdot t^2$$</p>
            </div>

            <div class="formula-box">
                <h4>Vektorlar Bilan Amallar</h4>
                <p><strong>Vektorlarni qo'shish:</strong> $\vec{v}_1 + \vec{v}_2 = (v_{1x} + v_{2x})\hat{i} + (v_{1y} + v_{2y})\hat{j}$</p>
                <p><strong>Vektorlarni ayirish:</strong> $\vec{v}_1 - \vec{v}_2 = (v_{1x} - v_{2x})\hat{i} + (v_{1y} - v_{2y})\hat{j}$</p>
            </div>

            <h3>Real Hayotdagi Misollar</h3>
            <ul>
                <li><strong>Proyektil harakati:</strong> Top o'qi yoki futbol to'pining harakati</li>
                <li><strong>Aylana harakat:</strong> Planetalarning Quyosh atrofidagi harakati</li>
                <li><strong>Nisbiy harakat:</strong> Kemada yuruvchi odamning tezligi</li>
                <li><strong>Avtomobil harakati:</strong> Egri yo'lda harakatlanuvchi mashina</li>
            </ul>
        </div>
    </div>

    <script>
        class VelocityVectorSimulation {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Simulation parameters
                this.isRunning = false;
                this.time = 0;
                this.dt = 0.016; // 60 FPS
                this.speedMultiplier = 1;
                
                // Initial conditions
                this.x0 = 0;
                this.y0 = 0;
                this.vx0 = 20;
                this.vy0 = 15;
                this.ax = 0;
                this.ay = -9.8;
                
                // Current values
                this.reset();
                
                // Visualization settings
                this.scale = 3; // pixels per meter
                this.minScale = 0.5;
                this.maxScale = 20;
                this.originX = this.canvas.width / 2;
                this.originY = this.canvas.height / 2;
                this.showGrid = true;
                this.showTrail = true;
                this.trail = [];
                this.maxTrailLength = 200;
                this.autoScale = true;
                this.viewBuffer = 50; // pixels buffer around content
                
                // Vector display settings
                this.vectorScale = 5; // scale for vector display
                this.minVectorScale = 1;
                this.maxVectorScale = 20;
                this.showComponents = true;
                this.showResultant = true;
                
                this.setupEventListeners();
                this.updateUI();
                this.animate();
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Handle high DPI displays
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }
            
            setupEventListeners() {
                // Control sliders
                document.getElementById('vxSlider').addEventListener('input', (e) => {
                    this.vx0 = parseFloat(e.target.value);
                    this.resetViewScale();
                    this.updateUI();
                });
                
                document.getElementById('vySlider').addEventListener('input', (e) => {
                    this.vy0 = parseFloat(e.target.value);
                    this.resetViewScale();
                    this.updateUI();
                });
                
                document.getElementById('axSlider').addEventListener('input', (e) => {
                    this.ax = parseFloat(e.target.value);
                    this.resetViewScale();
                    this.updateUI();
                });
                
                document.getElementById('aySlider').addEventListener('input', (e) => {
                    this.ay = parseFloat(e.target.value);
                    this.resetViewScale();
                    this.updateUI();
                });
                
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.speedMultiplier = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.speedMultiplier.toFixed(1) + 'x';
                });
                
                // Control buttons
                document.getElementById('playPauseBtn').addEventListener('click', () => {
                    this.togglePlayPause();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('clearTrailBtn').addEventListener('click', () => {
                    this.trail = [];
                });
                
                // View control buttons
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.scale = Math.min(this.maxScale, this.scale * 1.5);
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.scale = Math.max(this.minScale, this.scale / 1.5);
                });
                
                document.getElementById('fitViewBtn').addEventListener('click', () => {
                    this.resetViewScale();
                });
                
                // View settings checkboxes
                document.getElementById('autoScaleCheck').addEventListener('change', (e) => {
                    this.autoScale = e.target.checked;
                });
                
                document.getElementById('showGridCheck').addEventListener('change', (e) => {
                    this.showGrid = e.target.checked;
                });
                
                document.getElementById('showTrailCheck').addEventListener('change', (e) => {
                    this.showTrail = e.target.checked;
                });
                
                document.getElementById('showComponentsCheck').addEventListener('change', (e) => {
                    this.showComponents = e.target.checked;
                });
                
                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.loadPreset(e.target.dataset.preset);
                    });
                });
                
                // Canvas interaction
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.setPositionFromClick(x, y);
                });
                
                // Mouse move tracking
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.updateMousePosition(x, y);
                });
                
                // Resize handling
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.resetViewScale();
                });
            }
            
            reset() {
                this.time = 0;
                this.x = this.x0;
                this.y = this.y0;
                this.vx = this.vx0;
                this.vy = this.vy0;
                this.trail = [];
                
                // Reset view scale based on initial parameters
                this.resetViewScale();
                
                this.updateUI();
            }
            
            togglePlayPause() {
                this.isRunning = !this.isRunning;
                const btn = document.getElementById('playPauseBtn');
                btn.textContent = this.isRunning ? '⏸️ Pauza' : '▶️ Boshlash';
            }
            
            loadPreset(preset) {
                const presets = {
                    projectile: { vx0: 20, vy0: 20, ax: 0, ay: -9.8 },
                    circular: { vx0: 15, vy0: 0, ax: 0, ay: 0 },
                    uniform: { vx0: 25, vy0: 0, ax: 0, ay: 0 },
                    deceleration: { vx0: 30, vy0: 10, ax: -2, ay: -1 }
                };
                
                if (presets[preset]) {
                    const p = presets[preset];
                    this.vx0 = p.vx0;
                    this.vy0 = p.vy0;
                    this.ax = p.ax;
                    this.ay = p.ay;
                    
                    // Update sliders
                    document.getElementById('vxSlider').value = p.vx0;
                    document.getElementById('vySlider').value = p.vy0;
                    document.getElementById('axSlider').value = p.ax;
                    document.getElementById('aySlider').value = p.ay;
                    
                    this.reset();
                }
            }
            
            setPositionFromClick(canvasX, canvasY) {
                this.x = (canvasX - this.originX) / this.scale;
                this.y = -(canvasY - this.originY) / this.scale;
                this.x0 = this.x;
                this.y0 = this.y;
                this.time = 0;
                this.trail = [];
                this.updateUI();
            }
            
            updateMousePosition(canvasX, canvasY) {
                const worldX = (canvasX - this.originX) / this.scale;
                const worldY = -(canvasY - this.originY) / this.scale;
                document.getElementById('mousePos').textContent = 
                    `Kursor: (${worldX.toFixed(1)}, ${worldY.toFixed(1)})`;
            }
            
            update() {
                if (!this.isRunning) return;
                
                const dt = this.dt * this.speedMultiplier;
                this.time += dt;
                
                // Update velocity
                this.vx = this.vx0 + this.ax * this.time;
                this.vy = this.vy0 + this.ay * this.time;
                
                // Update position
                this.x = this.x0 + this.vx0 * this.time + 0.5 * this.ax * this.time * this.time;
                this.y = this.y0 + this.vy0 * this.time + 0.5 * this.ay * this.time * this.time;
                
                // Add to trail
                if (this.showTrail) {
                    this.trail.push({
                        x: this.x,
                        y: this.y,
                        vx: this.vx,
                        vy: this.vy
                    });
                    
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
                
                // Auto-scale view if enabled
                if (this.autoScale) {
                    this.updateViewScale();
                }
                
                // Check bounds and reset if needed
                const maxDistance = 500; // meters
                if (Math.abs(this.x) > maxDistance || Math.abs(this.y) > maxDistance) {
                    this.reset();
                }
                
                this.updateUI();
            }
            
            updateViewScale() {
                // Calculate the extent of motion
                let minX = Math.min(this.x, this.x0);
                let maxX = Math.max(this.x, this.x0);
                let minY = Math.min(this.y, this.y0);
                let maxY = Math.max(this.y, this.y0);
                
                // Include trail points
                if (this.trail.length > 0) {
                    this.trail.forEach(point => {
                        minX = Math.min(minX, point.x);
                        maxX = Math.max(maxX, point.x);
                        minY = Math.min(minY, point.y);
                        maxY = Math.max(maxY, point.y);
                    });
                }
                
                // Add some buffer based on velocity vectors
                const vMag = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const buffer = Math.max(10, vMag * 2); // Dynamic buffer
                
                minX -= buffer;
                maxX += buffer;
                minY -= buffer;
                maxY += buffer;
                
                // Calculate required scale to fit content
                const rangeX = maxX - minX;
                const rangeY = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                // Calculate scale to fit content with buffer
                const scaleX = (this.canvas.width - 2 * this.viewBuffer) / rangeX;
                const scaleY = (this.canvas.height - 2 * this.viewBuffer) / rangeY;
                const targetScale = Math.min(scaleX, scaleY);
                
                // Smooth scale transition
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, targetScale));
                this.scale = this.scale * 0.95 + newScale * 0.05;
                
                // Update origin to center the content
                this.originX = this.canvas.width / 2 - centerX * this.scale;
                this.originY = this.canvas.height / 2 + centerY * this.scale;
                
                // Update vector scale proportionally
                this.vectorScale = Math.max(this.minVectorScale, 
                    Math.min(this.maxVectorScale, 50 / Math.max(1, vMag)));
            }
            
            resetViewScale() {
                // Calculate initial trajectory extents for better initial view
                const vMag = Math.sqrt(this.vx0 * this.vx0 + this.vy0 * this.vy0);
                
                // Estimate trajectory range based on initial conditions
                let estimatedRange = 50; // default range
                
                if (this.ay !== 0) {
                    // Projectile motion - estimate maximum range
                    const timeToMaxHeight = Math.abs(this.vy0 / this.ay);
                    const maxHeight = this.y0 + this.vy0 * timeToMaxHeight + 0.5 * this.ay * timeToMaxHeight * timeToMaxHeight;
                    const totalTime = 2 * timeToMaxHeight;
                    const maxRange = Math.abs(this.x0 + this.vx0 * totalTime + 0.5 * this.ax * totalTime * totalTime);
                    estimatedRange = Math.max(Math.abs(maxHeight), maxRange);
                }
                
                if (this.ax !== 0 || this.ay !== 0) {
                    // Motion with acceleration - estimate based on initial velocity and acceleration
                    const timeEstimate = Math.max(5, vMag / Math.max(1, Math.sqrt(this.ax * this.ax + this.ay * this.ay)));
                    const xRange = Math.abs(this.vx0 * timeEstimate + 0.5 * this.ax * timeEstimate * timeEstimate);
                    const yRange = Math.abs(this.vy0 * timeEstimate + 0.5 * this.ay * timeEstimate * timeEstimate);
                    estimatedRange = Math.max(xRange, yRange);
                }
                
                // Set initial scale to show estimated trajectory
                const padding = 1.5; // 50% padding
                estimatedRange *= padding;
                
                const scaleX = (this.canvas.width - 2 * this.viewBuffer) / (2 * estimatedRange);
                const scaleY = (this.canvas.height - 2 * this.viewBuffer) / (2 * estimatedRange);
                this.scale = Math.max(this.minScale, Math.min(this.maxScale, Math.min(scaleX, scaleY)));
                
                // Center the view
                this.originX = this.canvas.width / 2;
                this.originY = this.canvas.height / 2;
                
                // Set vector scale based on velocity magnitude
                this.vectorScale = Math.max(this.minVectorScale, 
                    Math.min(this.maxVectorScale, 50 / Math.max(1, vMag)));
            }
            
            updateUI() {
                // Update slider displays
                document.getElementById('vxValue').textContent = this.vx0.toFixed(1) + ' m/s';
                document.getElementById('vyValue').textContent = this.vy0.toFixed(1) + ' m/s';
                document.getElementById('axValue').textContent = this.ax.toFixed(1) + ' m/s²';
                document.getElementById('ayValue').textContent = this.ay.toFixed(1) + ' m/s²';
                
                // Update current values
                document.getElementById('currentVx').textContent = this.vx.toFixed(1) + ' m/s';
                document.getElementById('currentVy').textContent = this.vy.toFixed(1) + ' m/s';
                
                const magnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                document.getElementById('currentMagnitude').textContent = magnitude.toFixed(1) + ' m/s';
                
                const angle = Math.atan2(this.vy, this.vx) * 180 / Math.PI;
                document.getElementById('currentAngle').textContent = angle.toFixed(1) + '°';
                
                document.getElementById('currentTime').textContent = this.time.toFixed(1) + ' s';
                document.getElementById('currentPosition').textContent = 
                    `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`;
                
                // Update scale info
                const scaleRatio = this.scale.toFixed(2);
                const metersPerPixel = (1 / this.scale).toFixed(2);
                document.getElementById('scaleInfo').textContent = 
                    `Masshtab: ${scaleRatio} px/m (${metersPerPixel} m/px)`;
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                if (this.showGrid) {
                    this.drawGrid();
                }
                
                // Draw trail
                if (this.showTrail && this.trail.length > 1) {
                    this.drawTrail();
                }
                
                // Draw axes
                this.drawAxes();
                
                // Draw particle
                this.drawParticle();
                
                // Draw velocity vector
                this.drawVelocityVector();
                
                // Draw legend
                this.drawLegend();
            }
            
            drawGrid() {
                const gridSpacing = 50; // meters
                const gridPixelSpacing = gridSpacing * this.scale;
                
                // Don't draw grid if too dense or too sparse
                if (gridPixelSpacing < 10 || gridPixelSpacing > 200) return;
                
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.lineWidth = 1;
                
                // Calculate grid bounds
                const minX = Math.floor((-this.originX) / gridPixelSpacing) * gridPixelSpacing;
                const maxX = Math.ceil((this.canvas.width - this.originX) / gridPixelSpacing) * gridPixelSpacing;
                const minY = Math.floor((-this.originY) / gridPixelSpacing) * gridPixelSpacing;
                const maxY = Math.ceil((this.canvas.height - this.originY) / gridPixelSpacing) * gridPixelSpacing;
                
                // Vertical lines
                for (let x = minX; x <= maxX; x += gridPixelSpacing) {
                    const screenX = this.originX + x;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, 0);
                    this.ctx.lineTo(screenX, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = minY; y <= maxY; y += gridPixelSpacing) {
                    const screenY = this.originY + y;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                }
                
                // Draw grid labels
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.font = '10px Arial';
                
                // X-axis labels
                for (let x = minX; x <= maxX; x += gridPixelSpacing) {
                    if (x === 0) continue; // Skip origin
                    const screenX = this.originX + x;
                    const value = Math.round(x / this.scale);
                    if (screenX > 20 && screenX < this.canvas.width - 20) {
                        this.ctx.fillText(value.toString(), screenX - 5, this.originY + 15);
                    }
                }
                
                // Y-axis labels
                for (let y = minY; y <= maxY; y += gridPixelSpacing) {
                    if (y === 0) continue; // Skip origin
                    const screenY = this.originY + y;
                    const value = Math.round(-y / this.scale);
                    if (screenY > 15 && screenY < this.canvas.height - 15) {
                        this.ctx.fillText(value.toString(), this.originX + 5, screenY + 3);
                    }
                }
            }
            
            drawAxes() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                
                // X-axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.originY);
                this.ctx.lineTo(this.canvas.width, this.originY);
                this.ctx.stroke();
                
                // Y-axis
                this.ctx.beginPath();
                this.ctx.moveTo(this.originX, 0);
                this.ctx.lineTo(this.originX, this.canvas.height);
                this.ctx.stroke();
                
                // Axis labels
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('X', this.canvas.width - 20, this.originY - 10);
                this.ctx.fillText('Y', this.originX + 10, 20);
            }
            
            drawTrail() {
                if (this.trail.length < 2) return;
                
                this.ctx.strokeStyle = '#667eea';
                this.ctx.lineWidth = 2;
                this.ctx.globalAlpha = 0.3;
                
                this.ctx.beginPath();
                const firstPoint = this.trail[0];
                this.ctx.moveTo(
                    this.originX + firstPoint.x * this.scale,
                    this.originY - firstPoint.y * this.scale
                );
                
                for (let i = 1; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    this.ctx.lineTo(
                        this.originX + point.x * this.scale,
                        this.originY - point.y * this.scale
                    );
                }
                
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }
            
            drawParticle() {
                const screenX = this.originX + this.x * this.scale;
                const screenY = this.originY - this.y * this.scale;
                
                // Draw particle
                this.ctx.fillStyle = '#e53e3e';
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, 8, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw particle border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
            
            drawVelocityVector() {
                const screenX = this.originX + this.x * this.scale;
                const screenY = this.originY - this.y * this.scale;
                
                // Draw velocity components
                if (this.showComponents) {
                    // X component
                    this.drawVector(
                        screenX, screenY,
                        this.vx * this.vectorScale, 0,
                        '#ff6b6b', 'vₓ'
                    );
                    
                    // Y component
                    this.drawVector(
                        screenX, screenY,
                        0, -this.vy * this.vectorScale,
                        '#4ecdc4', 'vᵧ'
                    );
                }
                
                // Draw resultant vector
                if (this.showResultant) {
                    this.drawVector(
                        screenX, screenY,
                        this.vx * this.vectorScale, -this.vy * this.vectorScale,
                        '#667eea', 'v⃗'
                    );
                }
            }
            
            drawVector(startX, startY, deltaX, deltaY, color, label) {
                if (Math.abs(deltaX) < 0.1 && Math.abs(deltaY) < 0.1) return;
                
                const endX = startX + deltaX;
                const endY = startY + deltaY;
                
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = 3;
                
                // Draw vector line
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Draw arrowhead
                const angle = Math.atan2(deltaY, deltaX);
                const arrowLength = 10;
                const arrowAngle = Math.PI / 6;
                
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - arrowAngle),
                    endY - arrowLength * Math.sin(angle - arrowAngle)
                );
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + arrowAngle),
                    endY - arrowLength * Math.sin(angle + arrowAngle)
                );
                this.ctx.closePath();
                this.ctx.fill();
                
                // Draw label
                this.ctx.fillStyle = color;
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillText(label, endX + 5, endY - 5);
            }
            
            drawLegend() {
                const legendX = 10;
                const legendY = 10;
                const lineHeight = 25;
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.fillRect(legendX, legendY, 200, 100);
                
                this.ctx.strokeStyle = '#ccc';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(legendX, legendY, 200, 100);
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('Legendlar:', legendX + 10, legendY + 20);
                
                // Draw legend items
                const legendItems = [
                    { color: '#ff6b6b', label: 'vₓ - Gorizontal tezlik' },
                    { color: '#4ecdc4', label: 'vᵧ - Vertikal tezlik' },
                    { color: '#667eea', label: 'v⃗ - Natija tezlik' }
                ];
                
                legendItems.forEach((item, index) => {
                    const y = legendY + 40 + index * 20;
                    
                    // Draw color indicator
                    this.ctx.fillStyle = item.color;
                    this.ctx.fillRect(legendX + 10, y - 8, 15, 3);
                    
                    // Draw label
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillText(item.label, legendX + 30, y);
                });
            }
            
            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const simulation = new VelocityVectorSimulation();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        simulation.togglePlayPause();
                        break;
                    case 'r':
                        simulation.reset();
                        break;
                    case 'c':
                        simulation.trail = [];
                        break;
                }
            });
            
            // Add touch support for mobile
            let touchStartX, touchStartY;
            
            simulation.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            simulation.canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                const rect = simulation.canvas.getBoundingClientRect();
                const x = touchStartX - rect.left;
                const y = touchStartY - rect.top;
                simulation.setPositionFromClick(x, y);
            });
        });
    </script>
</body>

</html>




